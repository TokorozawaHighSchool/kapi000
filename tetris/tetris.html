<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>テトリス</title>
  <style>
    body { background: #222; color: #fff; text-align: center; }
    #game { margin: 20px auto; display: grid; grid-template: repeat(20, 24px) / repeat(10, 24px); gap: 2px; }
    .cell { width: 24px; height: 24px; background: #333; border-radius: 4px; }
    .active { background: #e74c3c; }
    .fixed { background: #3498db; }
    #score { font-size: 1.2em; margin: 10px; }
    #reset { margin: 10px; padding: 8px 16px; font-size: 1em; }
  </style>
</head>
<body>
  <h1>テトリス</h1>
  <div id="score">スコア: 0</div>
  <button id="reset">リセット</button>
    <button id="hold">ホールド(C)</button>
    <span id="holdBox"><span id="holdLabel">ホールド:</span></span>
  <div id="game"></div>
  <script>
    const COLS = 10, ROWS = 20;
    const SHAPES = [
      [[1,1,1,1]], // I
      [[1,1],[1,1]], // O
      [[0,1,0],[1,1,1]], // T
      [[1,0,0],[1,1,1]], // J
      [[0,0,1],[1,1,1]], // L
      [[1,1,0],[0,1,1]], // S
      [[0,1,1],[1,1,0]]  // Z
    ];
    let board, current, pos, score = 0, gameOver = false;
    let holdShape = null, holdUsed = false;
    const holdBtn = document.getElementById('hold');
    const holdBox = document.getElementById('holdBox');
    const gameElem = document.getElementById('game');
    const scoreElem = document.getElementById('score');
    const resetBtn = document.getElementById('reset');

    function init() {
      board = Array.from({length: ROWS}, () => Array(COLS).fill(0));
      score = 0;
      gameOver = false;
    holdShape = null;
    holdUsed = false;
      spawn();
      draw();
      scoreElem.textContent = 'スコア: ' + score;
    drawHold();
    }

    function spawn(nextHoldType = null) {
      const type = nextHoldType !== null ? nextHoldType : Math.floor(Math.random() * SHAPES.length);
      current = SHAPES[type].map(row => [...row]);
      current.type = type;
      pos = {x: Math.floor(COLS/2)-1, y: 0};
      if (!validMove(0,0,current)) gameOver = true;
      holdUsed = false;
    }

    function draw() {
      gameElem.innerHTML = '';
      for (let y = 0; y < ROWS; y++) {
        for (let x = 0; x < COLS; x++) {
          const cell = document.createElement('div');
          cell.className = 'cell' + (board[y][x] ? ' fixed' : '');
          gameElem.appendChild(cell);
        }
      }
      // Draw active piece
      if (!gameOver) {
        for (let y = 0; y < current.length; y++) {
          for (let x = 0; x < current[y].length; x++) {
            if (current[y][x]) {
              const idx = (pos.y + y) * COLS + (pos.x + x);
              if (idx >= 0 && idx < ROWS*COLS && pos.y + y >= 0 && pos.x + x >= 0 && pos.x + x < COLS && pos.y + y < ROWS) {
                gameElem.children[idx].classList.add('active');
              }
            }
          }
        }
      }
      if (gameOver) {
        setTimeout(() => alert('ゲームオーバー！スコア: ' + score), 100);
      }
        drawHold();
    }

      function drawHold() {
        holdBox.innerHTML = '<span id="holdLabel">ホールド:</span>';
        if (holdShape !== null) {
          const shape = SHAPES[holdShape];
          for (let y = 0; y < shape.length; y++) {
            for (let x = 0; x < shape[y].length; x++) {
              const cell = document.createElement('span');
              cell.style.display = 'inline-block';
              cell.style.width = '18px';
              cell.style.height = '18px';
              cell.style.background = shape[y][x] ? '#e74c3c' : '#555';
              cell.style.margin = '1px';
              cell.style.borderRadius = '4px';
              holdBox.appendChild(cell);
            }
            holdBox.appendChild(document.createElement('br'));
          }
        }
      }

    function validMove(dx, dy, shape) {
      for (let y = 0; y < shape.length; y++) {
        for (let x = 0; x < shape[y].length; x++) {
          if (shape[y][x]) {
            const nx = pos.x + x + dx;
            const ny = pos.y + y + dy;
            if (nx < 0 || nx >= COLS || ny >= ROWS) return false;
            if (ny >= 0 && board[ny][nx]) return false;
          }
        }
      }
      return true;
    }

    function merge() {
      for (let y = 0; y < current.length; y++) {
        for (let x = 0; x < current[y].length; x++) {
          if (current[y][x]) {
            board[pos.y + y][pos.x + x] = 1;
          }
        }
      }
        // T-スピン判定
        if (isTSpin()) {
          score += 400;
          scoreElem.textContent = 'スコア: ' + score + ' (T-スピン!)';
          setTimeout(() => { scoreElem.textContent = 'スコア: ' + score; }, 1000);
        }
    }
    // T-スピン判定
    function isTSpin() {
      // T型ミノのみ
      if (current.type !== 2) return false;
      // Tの中心座標
      const cx = pos.x + 1, cy = pos.y + 1;
      let corners = 0;
      [[0,0],[2,0],[0,2],[2,2]].forEach(([dx,dy]) => {
        const x = cx + dx - 1, y = cy + dy - 1;
        if (x < 0 || x >= COLS || y < 0 || y >= ROWS || board[y][x]) corners++;
      });
      return corners >= 3;
    }

    function clearLines() {
      let lines = 0;
      for (let y = ROWS-1; y >= 0; y--) {
        if (board[y].every(cell => cell)) {
          board.splice(y,1);
          board.unshift(Array(COLS).fill(0));
          lines++;
          y++;
        }
      }
      score += lines * 100;
      scoreElem.textContent = 'スコア: ' + score;
    }

    function rotate(shape) {
      const w = shape[0].length, h = shape.length;
      const rotated = Array.from({length: w}, () => Array(h).fill(0));
      for (let y = 0; y < h; y++) {
        for (let x = 0; x < w; x++) {
          rotated[x][h-1-y] = shape[y][x];
        }
      }
    rotated.type = shape.type;
      return rotated;
    }

    function tick() {
      if (gameOver) return;
      if (validMove(0,1,current)) {
        pos.y++;
      } else {
        merge();
        clearLines();
    spawn();
    drawHold();
      }
      draw();
    }

    document.addEventListener('keydown', e => {
      if (gameOver) return;
      if (e.key === 'ArrowLeft' && validMove(-1,0,current)) {
        pos.x--;
      } else if (e.key === 'ArrowRight' && validMove(1,0,current)) {
        pos.x++;
      } else if (e.key === 'ArrowDown' && validMove(0,1,current)) {
        pos.y++;
      } else if (e.key === 'ArrowUp') {
        const rotated = rotate(current);
        if (validMove(0,0,rotated)) current = rotated;
      } else if (e.key === ' ') {
        // ハードドロップ
        while (validMove(0,1,current)) pos.y++;
        tick();
        } else if (e.key.toLowerCase() === 'c') {
          hold();
      }
      draw();
    });

      holdBtn.onclick = hold;

      function hold() {
        if (holdUsed) return;
        const curType = current.type;
        if (holdShape === null) {
          holdShape = curType;
          spawn();
        } else {
          const tmp = holdShape;
          holdShape = curType;
          spawn(tmp);
        }
        holdUsed = true;
        drawHold();
        draw();
      }

    resetBtn.onclick = () => {
      init();
    };

    init();
    setInterval(tick, 500);
  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>テトリス</title>
  <style>
    body { background: #222; color: #fff; text-align: center; }
    canvas { background: #111; display: block; margin: 0 auto; }
    #score { font-size: 1.5em; margin: 10px; }
  </style>
</head>
<body>
  <h1>テトリス</h1>
  <div id="score">スコア: 0</div>
  <canvas id="tetris" width="240" height="400"></canvas>
  <script>
    const canvas = document.getElementById('tetris');
    const ctx = canvas.getContext('2d');
    const scoreElem = document.getElementById('score');
    const COLS = 10, ROWS = 20, BLOCK_SIZE = 24;
    const COLORS = [
      null, '#00f0f0', '#0000f0', '#f0a000', '#f0f000', '#00f000', '#a000f0', '#f00000'
    ];
    const SHAPES = [
      [],
      [[1,1,1,1]], // I
      [[2,0,0],[2,2,2]], // J
      [[0,0,3],[3,3,3]], // L
      [[4,4],[4,4]], // O
      [[0,5,5],[5,5,0]], // S
      [[0,6,0],[6,6,6]], // T
      [[7,7,0],[0,7,7]]  // Z
    ];
    let board = Array.from({length: ROWS}, () => Array(COLS).fill(0));
    let score = 0, dropCounter = 0, dropInterval = 1600; // スピードを遅く
    let piece = null;

    function drawBlock(x, y, color) {
      ctx.fillStyle = color;
      ctx.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
      ctx.strokeStyle = '#222';
      ctx.strokeRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
    }

    function drawBoard() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      for (let y = 0; y < ROWS; y++)
        for (let x = 0; x < COLS; x++)
          if (board[y][x]) drawBlock(x, y, COLORS[board[y][x]]);
      if (piece) drawPiece();
    }

    function drawPiece() {
      piece.shape.forEach((row, dy) =>
        row.forEach((value, dx) => {
          if (value)
            drawBlock(piece.x + dx, piece.y + dy, COLORS[value]);
        })
      );
    }

    function collide(board, piece) {
      for (let y = 0; y < piece.shape.length; y++)
        for (let x = 0; x < piece.shape[y].length; x++)
          if (piece.shape[y][x] &&
              (board[piece.y + y] && board[piece.y + y][piece.x + x]) !== 0)
            return true;
      return false;
    }

    function merge(board, piece) {
      piece.shape.forEach((row, dy) =>
        row.forEach((value, dx) => {
          if (value)
            board[piece.y + dy][piece.x + dx] = value;
        })
      );
    }

    function rotate(matrix) {
      return matrix[0].map((_, i) => matrix.map(row => row[i])).reverse();
    }

    function drop() {
      piece.y++;
      if (collide(board, piece)) {
        piece.y--;
        merge(board, piece);
        resetPiece();
        sweep();
      }
      dropCounter = 0;
    }

    function sweep() {
      let lines = 0;
      outer: for (let y = ROWS - 1; y >= 0; y--) {
        for (let x = 0; x < COLS; x++)
          if (!board[y][x]) continue outer;
        board.splice(y, 1);
        board.unshift(Array(COLS).fill(0));
        lines++;
        y++;
      }
      if (lines) {
        score += lines * 100;
        scoreElem.textContent = 'スコア: ' + score;
      }
    }

    function resetPiece() {
      const type = Math.floor(Math.random() * (SHAPES.length - 1)) + 1;
      piece = {
        shape: SHAPES[type].map(row => [...row]),
        x: Math.floor(COLS / 2) - Math.ceil(SHAPES[type][0].length / 2),
        y: 0
      };
      if (collide(board, piece)) {
        board = Array.from({length: ROWS}, () => Array(COLS).fill(0));
        score = 0;
        scoreElem.textContent = 'スコア: 0';
      }
    }

    function move(dir) {
      piece.x += dir;
      // 枠外に出ないように制限
      if (piece.x < 0) piece.x = 0;
      if (piece.x + piece.shape[0].length > COLS) piece.x = COLS - piece.shape[0].length;
      if (collide(board, piece)) piece.x -= dir;
    }

    function rotatePiece() {
      const oldShape = piece.shape;
      piece.shape = rotate(piece.shape);
      // 回転後に枠外に出ないように制限
      if (piece.x < 0) piece.x = 0;
      if (piece.x + piece.shape[0].length > COLS) piece.x = COLS - piece.shape[0].length;
      if (collide(board, piece)) piece.shape = oldShape;
    }

    function update(time = 0) {
      dropCounter += time;
      if (dropCounter > dropInterval) drop();
      drawBoard();
      requestAnimationFrame(update);
    }

    document.addEventListener('keydown', e => {
      if (!piece) return;
      if (e.key === 'ArrowLeft') move(-1);
      else if (e.key === 'ArrowRight') move(1);
      else if (e.key === 'ArrowDown') drop();
      else if (e.key === 'ArrowUp') rotatePiece();
    });

    resetPiece();
    update();

  </script>
</body>
</html>
